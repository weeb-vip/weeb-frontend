---
import SvelteLayout from '../layouts/SvelteLayout.astro';
import HomepageSSR from '../svelte/components/HomepageSSR.svelte';
import { GraphQLClient } from 'graphql-request';
// Config now loaded via middleware - no direct import needed
import {
  getHomePageData,
  getCurrentlyAiringWithDates,
  getSeasonalAnime
} from '../services/api/graphql/queries';

// Access SSR auth data
const { auth, config } = Astro.locals;

// Function to get current season
function getCurrentSeason(): string {
  const now = new Date();
  const month = now.getMonth();
  const year = now.getFullYear();

  if (month >= 0 && month <= 2) return `WINTER_${year}`;
  if (month >= 3 && month <= 5) return `SPRING_${year}`;
  if (month >= 6 && month <= 8) return `SUMMER_${year}`;
  return `FALL_${year}`;
}

// Create authenticated GraphQL client for SSR
function createSSRGraphQLClient(authToken: string | undefined) {
  console.log('🌐 SSR GraphQL URL:', config.graphql_host);
  return new GraphQLClient(config.graphql_host, {
    headers: {
      ...(authToken && { Authorization: `Bearer ${authToken}` })
    },
    fetch: (input: RequestInfo | URL, init?: RequestInit) => {
      return fetch(input, {
        ...init,
        credentials: 'include'
      });
    }
  });
}

// Helper function to check if error is auth-related
function isAuthError(error: any): boolean {
  const message = error?.message?.toLowerCase() || '';
  const response = error?.response;

  // Check for GraphQL errors in the error response
  if (response?.errors && Array.isArray(response.errors)) {
    const hasAuthError = response.errors.some((err: any) => {
      const msg = (err.message || '').toLowerCase();
      return msg.includes('access denied') ||
             msg.includes('unauthorized') ||
             msg.includes('invalid token') ||
             msg.includes('jwt') ||
             msg.includes('authentication') ||
             msg.includes('forbidden') ||
             msg.includes('expired');
    });
    if (hasAuthError) return true;
  }

  // Also check for auth errors in the error message itself
  return message.includes('access denied') ||
         message.includes('unauthorized') ||
         message.includes('invalid token') ||
         message.includes('jwt') ||
         message.includes('authentication') ||
         message.includes('forbidden') ||
         message.includes('expired');
}

// Fetch all data server-side
let homeData: any = null;
let currentlyAiringData: any = null;
let seasonalData: any = null;
let ssrError: string | null = null;
let isTokenExpired = false;

const currentSeason = getCurrentSeason();

try {
  const client = createSSRGraphQLClient(auth.authToken);

  // Helper function to fetch with timeout and error handling
  async function fetchWithFallback(query, variables, description) {
    try {
      // Allow longer timeout for SSR - you'll optimize APIs on backend
      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Request timeout')), 10000)
      );

      const requestPromise = client.request(query, variables);
      return await Promise.race([requestPromise, timeoutPromise]);
    } catch (error) {
      console.error(`[SSR] Failed to fetch ${description}:`, error);

      if (isAuthError(error)) {
        console.warn(`[SSR] Auth error detected for ${description} - token may be expired`);
        isTokenExpired = true;

        // Try fetching without auth token for public data
        try {
          const publicClient = createSSRGraphQLClient(undefined);
          const timeoutPromise = new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Public request timeout')), 8000)
          );

          const publicRequestPromise = publicClient.request(query, variables);
          return await Promise.race([publicRequestPromise, timeoutPromise]);
        } catch (publicError) {
          console.error(`[SSR] Failed to fetch ${description} without auth:`, publicError);
          return null;
        }
      }
      return null;
    }
  }

  // Prepare request parameters
  const defaultStartDate = new Date(Date.now() - 24 * 60 * 60 * 1000);
  const defaultEndDate = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);

  // Fetch all data in parallel for better performance
  const [homeResult, currentlyAiringResult, seasonalResult] = await Promise.allSettled([
    fetchWithFallback(getHomePageData, { limit: 20 }, 'home data'),
    fetchWithFallback(getCurrentlyAiringWithDates, {
      input: { startDate: defaultStartDate, endDate: defaultEndDate }
    }, 'currently airing data'),
    fetchWithFallback(getSeasonalAnime, { season: currentSeason }, 'seasonal data')
  ]);

  // Extract results
  homeData = homeResult.status === 'fulfilled' ? homeResult.value : null;
  currentlyAiringData = currentlyAiringResult.status === 'fulfilled' ? currentlyAiringResult.value : null;
  seasonalData = seasonalResult.status === 'fulfilled' ? seasonalResult.value : null;


} catch (error) {
  console.error('[SSR] Failed to create GraphQL client:', error);
  ssrError = 'Failed to load data';
}

// If token was expired, update auth status
if (isTokenExpired) {
  console.log('[SSR] Token expired detected - updating auth locals');
  auth.isLoggedIn = false;
  auth.authToken = undefined;
  auth.refreshToken = undefined;
  auth.hasAuthToken = false;
  auth.hasRefreshToken = false;
}

// Get the first banner image for preloading
let bannerImageUrl = null;
if (currentlyAiringData?.getAiringAnimeAll?.length > 0) {
  const firstAnime = currentlyAiringData.getAiringAnimeAll[0];
  if (firstAnime.thetvdbid) {
    bannerImageUrl = `https://weeb-api.staging.weeb.vip/show/anime/series/${firstAnime.thetvdbid}/fanart?w=1920&h=1080&fit=cover&q=85&f=webp`;
  } else if (firstAnime.anidbid) {
    bannerImageUrl = `https://weeb-api.staging.weeb.vip/show/anime/anidb/series/${firstAnime.anidbid}/fanart?w=1920&h=1080&fit=cover&q=85&f=webp`;
  }
}

export const prerender = false;
---

<SvelteLayout
  title="Home"
  description="Discover and track your favorite anime. Get notifications for new episodes, explore seasonal anime, and manage your watchlist."
>
  {bannerImageUrl && (
    <link slot="head" rel="preload" as="image" href={bannerImageUrl} fetchpriority="high" />
  )}
  <HomepageSSR
    client:load
    {auth}
    {homeData}
    {currentlyAiringData}
    {seasonalData}
    {currentSeason}
    {ssrError}
    {isTokenExpired}
  />
</SvelteLayout>
